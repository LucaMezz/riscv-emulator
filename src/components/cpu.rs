#![allow(dead_code)]

use crate::isa::Instruction;

use super::{bus::DRAM_BASE, memory::{registers::Register::*, RegisterFile, Size, MMU}};

#[derive(Clone, PartialEq, Eq)]
pub enum Xlen {
	Bit32,
	Bit64
}

#[derive(Clone, PartialEq, Eq)]
pub enum PrivilegeMode {
	User,
	Supervisor,
	Reserved,
	Machine
}

#[derive(Debug, PartialEq, Eq)]
pub enum Trap {
	Breakpoint,
    EnvironmentCallFromMMode,
    EnvironmentCallFromSMode,
    EnvironmentCallFromUMode,
    IllegalInstruction,
    InstructionAccessFault,
    InstructionAddressMisaligned,
    InstructionPageFault,
    LoadAccessFault,
    LoadAddressMisaligned,
    LoadPageFault,
    MachineExternalInterrupt,
    MachineSoftwareInterrupt,
    MachineTimerInterrupt,
    StoreAccessFault,
    StoreAddressMisaligned,
    StorePageFault,
    SupervisorExternalInterrupt,
    SupervisorSoftwareInterrupt,
    SupervisorTimerInterrupt,
    UserExternalInterrupt,
    UserSoftwareInterrupt,
    UserTimerInterrupt
}

pub struct CPU {
    clock: u64,
    xlen: Xlen,
    pmode: PrivilegeMode,
    pc: u64,
    xregs: RegisterFile<u64>,
    fregs: RegisterFile<f64>, 
    mmu: MMU,
}

impl CPU {
    pub fn new() -> Self {
        let mut cpu = Self {
            clock: 0,
            xlen: Xlen::Bit64,
            pmode: PrivilegeMode::Machine,
            pc: DRAM_BASE,
            xregs: RegisterFile::new(),
            fregs: RegisterFile::new(),
            mmu: MMU::new(),
        };
        cpu.xregs.write(X11, 0x1020);
        cpu
    }

    /// Retrieves a mutable reference to the MMU.
    pub fn mmu(&mut self) -> &mut MMU {
        &mut self.mmu
    }

    /// Begins the execution of the CPU.
    pub fn run(&mut self) {
        loop {
            self.tick();
        } 
    }

    /// Retrieves the current address stored in the program counter.
    fn read_pc(&self) -> u64 {
        self.pc
    }    

    /// Sets the program counter to a new value.
    fn update_pc(&mut self, addr: u64) {
        self.pc = addr;
    }

    /// Increments the program counter by a specified value. Cycles back to 0 if it exceeds 2^64-1.
    fn incr_pc(&mut self, amount: u64) {
        self.pc = self.pc.wrapping_add(amount);
    }

    /// Increments the clock by 1. Cycles back to 0 if it exceeds 2^64-1.
    fn incr_clock(&mut self) {
        self.clock = self.clock.wrapping_add(1);
    }

    /// Fetches the next instruction through the MMU according to the value in the program counter,
    /// then increments the program counter.
    fn fetch(&mut self) -> Result<u64, Trap> {
        let word = self.mmu.load(self.pc, Size::Word);
        self.incr_pc(4);
        word
    }

    /// Decodes an instruction from its binary form.
    fn decode(&mut self, inst: u32) -> Instruction {
        Instruction::decode(inst)
    }

    /// Executes a decoded instruction.
    fn execute(&mut self, _inst: Instruction) -> Result<(), Trap> {
        unimplemented!()
    }

    /// Handles a trap which has been generated by something in the machine.
    fn handle_trap(&self, trap: Trap) {
        panic!("{:#?}", trap);
    }

    /// Handles an exception that has been thrown by something in the machine.
    fn handle_exception(&self, excep: Trap) {
        self.handle_trap(excep);
    }

    /// Performs one tick of the cpu execution. This includes performing one cycle, and handling any
    /// interrupts and exceptions that may have occurred.
    fn tick(&mut self) {
        self.incr_clock();        
        let result = self.cycle();
        match result {
            Err(e) => self.handle_exception(e),
            Ok(_) => {},
        }
    }

    /// Performs the fetch, decode, execute stages to complete the current cycle of execution.
    fn cycle(&mut self) -> Result<(), Trap> {
        let fetched_inst = self.fetch();
        let raw_inst = match fetched_inst {
            Err(e) => return Err(e),
            Ok(inst) => inst,
        };
        let inst: Instruction = self.decode(raw_inst as u32);
        match inst {
            Instruction::UNDEF => return Err(Trap::IllegalInstruction),
            _ => {},
        };
        let result = self.execute(inst);
        
        result
    }
}

#[cfg(test)]
mod test {

}