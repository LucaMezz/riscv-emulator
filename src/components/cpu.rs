#![allow(dead_code, unused_variables)]

use crate::{isa::Instruction, util::{get_bits, sign_extend_64, unsigned_32}};

use super::{bus::DRAM_BASE, memory::{registers::Register::*, RegisterFile, Size, MMU}};

#[derive(Clone, PartialEq, Eq)]
pub enum Xlen {
	Bit32,
	Bit64
}

#[derive(Clone, PartialEq, Eq)]
pub enum PrivilegeMode {
	User,
	Supervisor,
	Reserved,
	Machine
}

#[derive(Debug, PartialEq, Eq)]
pub enum Trap {
	Breakpoint,
    EnvironmentCallFromMMode,
    EnvironmentCallFromSMode,
    EnvironmentCallFromUMode,
    IllegalInstruction,
    InstructionAccessFault,
    InstructionAddressMisaligned,
    InstructionPageFault,
    LoadAccessFault,
    LoadAddressMisaligned,
    LoadPageFault,
    MachineExternalInterrupt,
    MachineSoftwareInterrupt,
    MachineTimerInterrupt,
    StoreAccessFault,
    StoreAddressMisaligned,
    StorePageFault,
    SupervisorExternalInterrupt,
    SupervisorSoftwareInterrupt,
    SupervisorTimerInterrupt,
    UserExternalInterrupt,
    UserSoftwareInterrupt,
    UserTimerInterrupt
}

pub struct CPU {
    clock: u64,
    xlen: Xlen,
    pmode: PrivilegeMode,
    pc: u64,
    xregs: RegisterFile<u64>,
    fregs: RegisterFile<f64>, 
    mmu: MMU,
}

impl CPU {
    pub fn new() -> Self {
        let mut cpu = Self {
            clock: 0,
            xlen: Xlen::Bit64,
            pmode: PrivilegeMode::Machine,
            pc: DRAM_BASE,
            xregs: RegisterFile::new(),
            fregs: RegisterFile::new(),
            mmu: MMU::new(),
        };
        // For linux boot
        // cpu.xregs.write(X11, 0x1020);

        // Initialise stack pointer towards the end of the DRAM.
        cpu.xregs.write(X2, DRAM_BASE + 1024*1024*1024 - 64);
        cpu
    }

    /// Retrieves a mutable reference to the MMU.
    pub fn mmu(&mut self) -> &mut MMU {
        &mut self.mmu
    }

    /// Begins the execution of the CPU.
    pub fn run(&mut self) {
        loop {
            if self.pc == 0 {
                println!("stopped execution with exit code: {}", self.xregs.read(X10));
                return;
            }

            self.tick();
        } 
    }

    /// Retrieves the current address stored in the program counter.
    fn read_pc(&self) -> u64 {
        self.pc
    }    

    /// Sets the program counter to a new value.
    fn update_pc(&mut self, addr: u64) {
        self.pc = addr;
    }

    /// Increments the program counter by a specified value. Cycles back to 0 if it exceeds 2^64-1.
    fn incr_pc(&mut self, amount: u64) {
        self.pc = self.pc.wrapping_add(amount);
    }

    /// Increments the clock by 1. Cycles back to 0 if it exceeds 2^64-1.
    fn incr_clock(&mut self) {
        self.clock = self.clock.wrapping_add(1);
    }

    /// Fetches the next instruction through the MMU according to the value in the program counter.
    fn fetch(&mut self) -> Result<u64, Trap> {
        let word = self.mmu.load(self.pc, Size::Word);
        self.incr_pc(4);
        word
    }

    /// Decodes an instruction from its binary form.
    fn decode(&mut self, inst: u32) -> Instruction {
        Instruction::decode(inst)
    }

    /// Handles a trap which has been generated by something in the machine.
    fn handle_trap(&self, trap: Trap) {
        println!("{:#?}", trap);
        unimplemented!("trap handler not yet implemented")
    }

    /// Handles an exception that has been thrown by something in the machine.
    fn handle_exception(&self, excep: Trap) {
        self.handle_trap(excep);
    }

    /// Performs one tick of the cpu execution. This includes performing one cycle, and handling any
    /// interrupts and exceptions that may have occurred.
    fn tick(&mut self) {
        self.incr_clock();

        let result = self.cycle();
        // For now, stop execution if address 0x0000_0000 is reached        
        
        match result {
            Err(e) => self.handle_exception(e),
            Ok(_) => {},
        }
    }

    /// Performs the fetch, decode, execute stages to complete the current cycle of execution.
    fn cycle(&mut self) -> Result<(), Trap> {
        let fetched_inst = self.fetch();
        let raw_inst = match fetched_inst {
            Err(e) => return Err(e),
            Ok(inst) => inst,
        };
        println!("{:x}:       {:X}", self.pc, raw_inst);
        let inst: Instruction = self.decode(raw_inst as u32);
        match inst {
            Instruction::UNDEF => return Err(Trap::IllegalInstruction),
            _ => {},
        };
        let result = self.execute(inst);
        
        result
    }

    /// Executes a decoded instruction.
    fn execute(&mut self, inst: Instruction) -> Result<(), Trap> {
        use Instruction::*;
        return match inst {
            // UNDEF: Undefined instruction.
            UNDEF => Err(Trap::IllegalInstruction),

            /*
             * Binary Operations
             */
            ADD(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(params.rd, a + b);
                Ok(())
            }
            SUB(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(params.rd, a - b);
                Ok(())
            },
            XOR(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(params.rd, a ^ b);
                Ok(())
            },
            OR(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(params.rd, a | b);
                Ok(())
            },
            AND(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(params.rd, a * b);
                Ok(())
            },
            SLL(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(params.rd, a << b);
                Ok(())
            },
            SRL(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(params.rd, a >> b);
                Ok(())
            },
            SRA(params) => {
                let a = self.xregs.read_num(params.rs1) as i64;
                let b = self.xregs.read_num(params.rs2) as i64;
                self.xregs.write_num(params.rd, (a >> b) as u64);
                Ok(())
            },
            SLT(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                let result = ((a as i64) < (b as i64)) as u64;
                assert!(result == 0 || result == 1);
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            SLTU(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                let result = (a < b) as u64;
                assert!(result == 0 || result == 1);
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            ADDW(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(
                    params.rd, 
                    (sign_extend_64(unsigned_32(a), 32) + 
                     sign_extend_64(unsigned_32(b), 32)) as u64
                );
                Ok(())
            },
            SUBW(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(
                    params.rd, 
                    (sign_extend_64(unsigned_32(a), 32) - 
                     sign_extend_64(unsigned_32(b), 32)) as u64
                );
                Ok(())
            },
            SLLW(params)  => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(
                    params.rd, 
                    (sign_extend_64(unsigned_32(a), 32) << 
                     sign_extend_64(unsigned_32(b), 32)) as u64
                );
                Ok(())
            }
            SRLW(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(
                    params.rd, 
                    (sign_extend_64(unsigned_32(a), 32) >> 
                     sign_extend_64(unsigned_32(b), 32)) as u64
                );
                Ok(())
            },
            SRAW(params) => {
                let a = self.xregs.read_num(params.rs1);
                let b = self.xregs.read_num(params.rs2);
                self.xregs.write_num(
                    params.rd, 
                    sign_extend_64(
                        (unsigned_32(a) as i64 >> b as i64) as u64, 
                        32
                    ) as u64
                );
                Ok(())
            },

            /*
             * Binary Operations with an Immediate operand
             */
            ADDI(params) => {
                let result = self.xregs
                    .read_num(params.rs1)
                    .wrapping_add(params.imm as u64);
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            XORI(params) => {
                let result = self.xregs
                    .read_num(params.rs1) ^ params.imm as u64;
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            ORI(params) => {
                let result = self.xregs
                    .read_num(params.rs1) | params.imm as u64;
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            ANDI(params) => {
                let result = self.xregs
                    .read_num(params.rs1) & params.imm as u64;
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            SLLI(params) => {
                let result = self.xregs
                    .read_num(params.rs1) << get_bits(params.imm, 0, 4);
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            SRLI(params) => {
                let result = self.xregs
                    .read_num(params.rs1) >> get_bits(params.imm, 0, 4);
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            SRAI(params) => {
                let result = self.xregs
                    .read_num(params.rs1) as i64 >> get_bits(params.imm, 0, 4) as i64;
                self.xregs.write_num(params.rd, result as u64);
                Ok(())
            },
            SLTI(params) => {
                let a = self.xregs.read_num(params.rs1);
                let result = ((a as i64) < (params.imm as i64)) as u64;
                assert!(result == 0 || result == 1);
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            SLTIU(params) => {
                let a = self.xregs.read_num(params.rs1);
                let result = (a < params.imm as u64) as u64;
                assert!(result == 0 || result == 1);
                self.xregs.write_num(params.rd, result);
                Ok(())
            },

            ADDIW(params) => {
                let result = unsigned_32(self.xregs
                    .read_num(params.rs1))
                    .wrapping_add(params.imm as u64);
                self.xregs.write_num(params.rd, result);
                Ok(())
            },
            SLLIW(params) => {
                let result = unsigned_32(self.xregs
                    .read_num(params.rs1)) << params.imm as u64;
                self.xregs.write_num(
                    params.rd, 
                    sign_extend_64(result, 32) as u64
                );
                Ok(())
            },
            SRLIW(params) => {
                let result = unsigned_32(self.xregs
                    .read_num(params.rs1)) >> params.imm as u64;
                self.xregs.write_num(
                    params.rd, 
                    sign_extend_64(result, 32) as u64
                );
                Ok(())
            },
            SRAIW(params) => {
                let result = sign_extend_64(unsigned_32(self.xregs
                    .read_num(params.rs1)), 32) as i64 >> (params.imm as i64);
                self.xregs.write_num(
                    params.rd, 
                    result as u64,
                );
                Ok(())
            },

            /*
             * Load from memory
             */
            LB(params) |
            LH(params) |
            LW(params) |
            LD(params) |
            LBU(params) |
            LHU(params) |
            LWU(params) => {
                let addr = self.xregs
                    .read_num(params.rs1)
                    .wrapping_add(params.imm as u64);
                let size = match inst {
                    LB(_) => Size::Byte,
                    LH(_) => Size::HalfWord,
                    LW(_) => Size::Word,
                    LD(_) => Size::DoubleWord,
                    _ => unreachable!()
                };
                let data = match self.mmu.load(addr, size) {
                    Err(e) => return Err(e),
                    Ok(v) => match inst {
                        LBU(_) | 
                        LHU(_) | 
                        LWU(_) => v,
                        _ => sign_extend_64(v, size as u8 * 8) as u64
                    },
                };
                self.xregs.write_num(
                    params.rd, 
                    data
                );
                Ok(())
            },

            /*
             * Store to memory
             */
            SB(params) |
            SH(params) |
            SW(params) |
            SD(params) => {
                let addr = self.xregs
                    .read_num(params.rs1)
                    .wrapping_add(params.imm as u64);
                let size = match inst {
                    SB(_) => Size::Byte,
                    SH(_) => Size::HalfWord,
                    SW(_) => Size::Word,
                    SD(_) => Size::DoubleWord,
                    _ => unreachable!()
                };
                let data = self.xregs
                    .read_num(params.rs2)
                    .to_le_bytes()[0..size as usize]
                    .to_vec();
                self.mmu.store(addr, size, data)
            },

            /*
             * Branching
             */
            BEQ(params) => {
                if self.xregs.read_num(params.rs1) == self.xregs.read_num(params.rs2) 
                    { self.pc = self.pc + params.imm as u64 };
                Ok(())
            }
            BNE(params) => {
                if self.xregs.read_num(params.rs1) != self.xregs.read_num(params.rs2) 
                    { self.pc = self.pc + params.imm as u64 };
                Ok(())
            },
            BLT(params) => {
                if (self.xregs.read_num(params.rs1) as i64) 
                    < (self.xregs.read_num(params.rs2) as i64)
                    { self.pc = self.pc + params.imm as u64 };
                Ok(())
            },
            BLTU(params) => {
                if self.xregs.read_num(params.rs1) < self.xregs.read_num(params.rs2)
                    { self.pc = self.pc + params.imm as u64 };
                Ok(())
            },
            BGE(params) => {
                if (self.xregs.read_num(params.rs1) as i64) 
                    >= (self.xregs.read_num(params.rs2) as i64)
                    { self.pc = self.pc + params.imm as u64 };
                Ok(())
            }
            BGEU(params) => {
                if self.xregs.read_num(params.rs1) >= self.xregs.read_num(params.rs2)
                   { self.pc = self.pc + params.imm as u64 };
                Ok(())
            },

            /*
             * Jumping
             */
            JAL(params) => {
                self.xregs.write_num(params.rd, self.pc);
                self.pc = self.pc.wrapping_add(params.imm as u64);
                Ok(())
            },
            JALR(params) => {
                self.xregs.write_num(params.rd, self.pc + 4);
                let addr = self.xregs
                    .read_num(params.rs1)
                    .wrapping_add(params.imm as u64);
                self.update_pc(addr);
                Ok(())
            },

            /*
             * Upper immediates
             */
            LUI(params) => {
                self.xregs.write_num(params.rd, (params.imm as u64) << 12);
                Ok(())
            },
            AUIPC(params) => {
                self.incr_pc((params.imm as u64) << 12);
                Ok(())
            },

            /*
             * Environment
             */
            ECALL(params) => match self.pmode {
                PrivilegeMode::User => Err(Trap::EnvironmentCallFromUMode),
                PrivilegeMode::Supervisor => Err(Trap::EnvironmentCallFromSMode),
                PrivilegeMode::Machine => Err(Trap::EnvironmentCallFromMMode),
                PrivilegeMode::Reserved => panic!("Unknown privilege mode"),
            },
            EBREAK(params) => Err(Trap::Breakpoint),

            /*
             * Multiplication extension
             */
            MUL(params) => unimplemented!(),
            MULH(params) => unimplemented!(),
            MULSU(params) => unimplemented!(),
            MULU(params) => unimplemented!(),
            DIV(params) => unimplemented!(),
            DIVU(params) => unimplemented!(),
            REM(params) => unimplemented!(),
            REMU(params) => unimplemented!(),
            MULW(rtype_params) => unimplemented!(),
            DIVW(rtype_params) => unimplemented!(),
            DIVWU(rtype_params) => unimplemented!(),
            REMW(rtype_params) => unimplemented!(),
            REMWU(rtype_params) => unimplemented!(),
        };
    }
}

#[cfg(test)]
mod test {
    use num_traits::pow;

    use crate::{components::memory::registers::Register, isa::{decode::{ITypeParams, RTypeParams}, Instruction}};

    use super::CPU;

    
    #[test]
    pub fn it_executes_slt_and_sltu_correctly() {
        let mut cpu = CPU::new();
        let a: i64 = -707;
        let b: i64 = 578;
        cpu.xregs.write(Register::X10, a as u64);
        cpu.xregs.write(Register::X11, b as u64);
        let inst = Instruction::SLT(RTypeParams {
            rs1: Register::X10 as u8,
            rs2: Register::X11 as u8,
            rd: Register::X12 as u8,
        });
        let result = cpu.execute(inst);
        assert!(result.is_ok());
        let read = cpu.xregs.read(Register::X12);
        assert_eq!(read, true as u64);

        let inst2 = Instruction::SLTU(RTypeParams {
            rs1: Register::X10 as u8,
            rs2: Register::X11 as u8,
            rd: Register::X12 as u8,
        });
        let result2 = cpu.execute(inst2);
        assert!(result2.is_ok());
        let read2 = cpu.xregs.read(Register::X12);
        assert_eq!(read2, false as u64);
    }

    #[test]
    pub fn it_executes_word_instrs_correctly() {
        let mut cpu = CPU::new();
        let a: i32 = -1784;
        let b: i32 = -4392;
        let au: u32 = a as u32;
        let bu: u32 = b as u32;
        cpu.xregs.write(Register::X10, au as u64);
        cpu.xregs.write(Register::X11, bu as u64);
        let inst = Instruction::ADDW(RTypeParams {
            rs1: Register::X10 as u8,
            rs2: Register::X11 as u8,
            rd: Register::X12 as u8,
        });
        let result = cpu.execute(inst);
        assert!(result.is_ok());
        let read = cpu.xregs.read(Register::X12);
        assert_eq!(read, (a + b) as u64);

        let c = 5780;
        let d: i64 = pow(2, 48) + c;
        let e: i64 = -19384;
        cpu.xregs.write(Register::X10, d as u64);
        cpu.xregs.write(Register::X11, e as u64);
        let inst = Instruction::ADDW(RTypeParams {
            rs1: Register::X10 as u8,
            rs2: Register::X11 as u8,
            rd: Register::X12 as u8,
        });
        let result = cpu.execute(inst);
        assert!(result.is_ok());
        let read = cpu.xregs.read(Register::X12);
        assert_eq!(read, !13604 + 1);

        let inst = Instruction::ADDIW(ITypeParams {
            rs1: Register::X10 as u8,
            imm: e as i32,
            rd: Register::X12 as u8,
        });
        let result = cpu.execute(inst);
        assert!(result.is_ok());
        let read = cpu.xregs.read(Register::X12);
        assert_eq!(read, !13604 + 1);
        
        let f: i64 = -100;
        let imm: i64 = 5;
        cpu.xregs.write(Register::X10, f as u64);
        let inst = Instruction::SRAIW(ITypeParams {
            rs1: Register::X10 as u8,
            imm: imm as i32,
            rd: Register::X12 as u8,
        });
        let result = cpu.execute(inst);
        assert!(result.is_ok());
        let read = cpu.xregs.read(Register::X12);
        assert_eq!(read, (f >> imm) as u64);
    }
}
